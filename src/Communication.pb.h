// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Communication.proto

#ifndef PROTOBUF_Communication_2eproto__INCLUDED
#define PROTOBUF_Communication_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace org {
namespace hummingdroid {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Communication_2eproto();
void protobuf_AssignDesc_Communication_2eproto();
void protobuf_ShutdownFile_Communication_2eproto();

class Attitude;
class MotorsControl;
class PID;
class CommandPacket;
class CommandPacket_ControllerConfig;
class CommandPacket_TelemetryConfig;
class CommandPacket_SensorsConfig;
class CommandPacket_MotorsConfig;
class TelemetryPacket;

// ===================================================================

class Attitude : public ::google::protobuf::MessageLite {
 public:
  Attitude();
  virtual ~Attitude();

  Attitude(const Attitude& from);

  inline Attitude& operator=(const Attitude& from) {
    CopyFrom(from);
    return *this;
  }

  static const Attitude& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Attitude* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Attitude* other);

  // implements Message ----------------------------------------------

  Attitude* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Attitude& from);
  void MergeFrom(const Attitude& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float altitude = 1;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 1;
  inline float altitude() const;
  inline void set_altitude(float value);

  // required float roll = 2;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 2;
  inline float roll() const;
  inline void set_roll(float value);

  // required float pitch = 3;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 3;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float yaw_rate = 4;
  inline bool has_yaw_rate() const;
  inline void clear_yaw_rate();
  static const int kYawRateFieldNumber = 4;
  inline float yaw_rate() const;
  inline void set_yaw_rate(float value);

  // optional double timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.Attitude)
 private:
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw_rate();
  inline void clear_has_yaw_rate();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  float altitude_;
  float roll_;
  float pitch_;
  float yaw_rate_;
  double timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static Attitude* default_instance_;
};
// -------------------------------------------------------------------

class MotorsControl : public ::google::protobuf::MessageLite {
 public:
  MotorsControl();
  virtual ~MotorsControl();

  MotorsControl(const MotorsControl& from);

  inline MotorsControl& operator=(const MotorsControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const MotorsControl& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MotorsControl* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MotorsControl* other);

  // implements Message ----------------------------------------------

  MotorsControl* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MotorsControl& from);
  void MergeFrom(const MotorsControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float altitude_throttle = 1;
  inline bool has_altitude_throttle() const;
  inline void clear_altitude_throttle();
  static const int kAltitudeThrottleFieldNumber = 1;
  inline float altitude_throttle() const;
  inline void set_altitude_throttle(float value);

  // required float roll_throttle = 2;
  inline bool has_roll_throttle() const;
  inline void clear_roll_throttle();
  static const int kRollThrottleFieldNumber = 2;
  inline float roll_throttle() const;
  inline void set_roll_throttle(float value);

  // required float pitch_throttle = 3;
  inline bool has_pitch_throttle() const;
  inline void clear_pitch_throttle();
  static const int kPitchThrottleFieldNumber = 3;
  inline float pitch_throttle() const;
  inline void set_pitch_throttle(float value);

  // required float yaw_throttle = 4;
  inline bool has_yaw_throttle() const;
  inline void clear_yaw_throttle();
  static const int kYawThrottleFieldNumber = 4;
  inline float yaw_throttle() const;
  inline void set_yaw_throttle(float value);

  // optional double timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.MotorsControl)
 private:
  inline void set_has_altitude_throttle();
  inline void clear_has_altitude_throttle();
  inline void set_has_roll_throttle();
  inline void clear_has_roll_throttle();
  inline void set_has_pitch_throttle();
  inline void clear_has_pitch_throttle();
  inline void set_has_yaw_throttle();
  inline void clear_has_yaw_throttle();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  float altitude_throttle_;
  float roll_throttle_;
  float pitch_throttle_;
  float yaw_throttle_;
  double timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static MotorsControl* default_instance_;
};
// -------------------------------------------------------------------

class PID : public ::google::protobuf::MessageLite {
 public:
  PID();
  virtual ~PID();

  PID(const PID& from);

  inline PID& operator=(const PID& from) {
    CopyFrom(from);
    return *this;
  }

  static const PID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PID* other);

  // implements Message ----------------------------------------------

  PID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PID& from);
  void MergeFrom(const PID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float Kp = 1;
  inline bool has_kp() const;
  inline void clear_kp();
  static const int kKpFieldNumber = 1;
  inline float kp() const;
  inline void set_kp(float value);

  // required float Ki = 2;
  inline bool has_ki() const;
  inline void clear_ki();
  static const int kKiFieldNumber = 2;
  inline float ki() const;
  inline void set_ki(float value);

  // required float Kd = 3;
  inline bool has_kd() const;
  inline void clear_kd();
  static const int kKdFieldNumber = 3;
  inline float kd() const;
  inline void set_kd(float value);

  // required float Ko = 4;
  inline bool has_ko() const;
  inline void clear_ko();
  static const int kKoFieldNumber = 4;
  inline float ko() const;
  inline void set_ko(float value);

  // required float Td = 5;
  inline bool has_td() const;
  inline void clear_td();
  static const int kTdFieldNumber = 5;
  inline float td() const;
  inline void set_td(float value);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.PID)
 private:
  inline void set_has_kp();
  inline void clear_has_kp();
  inline void set_has_ki();
  inline void clear_has_ki();
  inline void set_has_kd();
  inline void clear_has_kd();
  inline void set_has_ko();
  inline void clear_has_ko();
  inline void set_has_td();
  inline void clear_has_td();

  float kp_;
  float ki_;
  float kd_;
  float ko_;
  float td_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static PID* default_instance_;
};
// -------------------------------------------------------------------

class CommandPacket_ControllerConfig : public ::google::protobuf::MessageLite {
 public:
  CommandPacket_ControllerConfig();
  virtual ~CommandPacket_ControllerConfig();

  CommandPacket_ControllerConfig(const CommandPacket_ControllerConfig& from);

  inline CommandPacket_ControllerConfig& operator=(const CommandPacket_ControllerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const CommandPacket_ControllerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPacket_ControllerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPacket_ControllerConfig* other);

  // implements Message ----------------------------------------------

  CommandPacket_ControllerConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPacket_ControllerConfig& from);
  void MergeFrom(const CommandPacket_ControllerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .org.hummingdroid.PID altitude_pid = 1;
  inline bool has_altitude_pid() const;
  inline void clear_altitude_pid();
  static const int kAltitudePidFieldNumber = 1;
  inline const ::org::hummingdroid::PID& altitude_pid() const;
  inline ::org::hummingdroid::PID* mutable_altitude_pid();
  inline ::org::hummingdroid::PID* release_altitude_pid();
  inline void set_allocated_altitude_pid(::org::hummingdroid::PID* altitude_pid);

  // required .org.hummingdroid.PID roll_pid = 2;
  inline bool has_roll_pid() const;
  inline void clear_roll_pid();
  static const int kRollPidFieldNumber = 2;
  inline const ::org::hummingdroid::PID& roll_pid() const;
  inline ::org::hummingdroid::PID* mutable_roll_pid();
  inline ::org::hummingdroid::PID* release_roll_pid();
  inline void set_allocated_roll_pid(::org::hummingdroid::PID* roll_pid);

  // required .org.hummingdroid.PID pitch_pid = 3;
  inline bool has_pitch_pid() const;
  inline void clear_pitch_pid();
  static const int kPitchPidFieldNumber = 3;
  inline const ::org::hummingdroid::PID& pitch_pid() const;
  inline ::org::hummingdroid::PID* mutable_pitch_pid();
  inline ::org::hummingdroid::PID* release_pitch_pid();
  inline void set_allocated_pitch_pid(::org::hummingdroid::PID* pitch_pid);

  // required .org.hummingdroid.PID yaw_rate_pid = 4;
  inline bool has_yaw_rate_pid() const;
  inline void clear_yaw_rate_pid();
  static const int kYawRatePidFieldNumber = 4;
  inline const ::org::hummingdroid::PID& yaw_rate_pid() const;
  inline ::org::hummingdroid::PID* mutable_yaw_rate_pid();
  inline ::org::hummingdroid::PID* release_yaw_rate_pid();
  inline void set_allocated_yaw_rate_pid(::org::hummingdroid::PID* yaw_rate_pid);

  // optional float max_inclinaison = 5;
  inline bool has_max_inclinaison() const;
  inline void clear_max_inclinaison();
  static const int kMaxInclinaisonFieldNumber = 5;
  inline float max_inclinaison() const;
  inline void set_max_inclinaison(float value);

  // optional float max_altitude = 6;
  inline bool has_max_altitude() const;
  inline void clear_max_altitude();
  static const int kMaxAltitudeFieldNumber = 6;
  inline float max_altitude() const;
  inline void set_max_altitude(float value);

  // optional float max_yaw_rate = 7;
  inline bool has_max_yaw_rate() const;
  inline void clear_max_yaw_rate();
  static const int kMaxYawRateFieldNumber = 7;
  inline float max_yaw_rate() const;
  inline void set_max_yaw_rate(float value);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.CommandPacket.ControllerConfig)
 private:
  inline void set_has_altitude_pid();
  inline void clear_has_altitude_pid();
  inline void set_has_roll_pid();
  inline void clear_has_roll_pid();
  inline void set_has_pitch_pid();
  inline void clear_has_pitch_pid();
  inline void set_has_yaw_rate_pid();
  inline void clear_has_yaw_rate_pid();
  inline void set_has_max_inclinaison();
  inline void clear_has_max_inclinaison();
  inline void set_has_max_altitude();
  inline void clear_has_max_altitude();
  inline void set_has_max_yaw_rate();
  inline void clear_has_max_yaw_rate();

  ::org::hummingdroid::PID* altitude_pid_;
  ::org::hummingdroid::PID* roll_pid_;
  ::org::hummingdroid::PID* pitch_pid_;
  ::org::hummingdroid::PID* yaw_rate_pid_;
  float max_inclinaison_;
  float max_altitude_;
  float max_yaw_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static CommandPacket_ControllerConfig* default_instance_;
};
// -------------------------------------------------------------------

class CommandPacket_TelemetryConfig : public ::google::protobuf::MessageLite {
 public:
  CommandPacket_TelemetryConfig();
  virtual ~CommandPacket_TelemetryConfig();

  CommandPacket_TelemetryConfig(const CommandPacket_TelemetryConfig& from);

  inline CommandPacket_TelemetryConfig& operator=(const CommandPacket_TelemetryConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const CommandPacket_TelemetryConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPacket_TelemetryConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPacket_TelemetryConfig* other);

  // implements Message ----------------------------------------------

  CommandPacket_TelemetryConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPacket_TelemetryConfig& from);
  void MergeFrom(const CommandPacket_TelemetryConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required bool commandEnabled = 3;
  inline bool has_commandenabled() const;
  inline void clear_commandenabled();
  static const int kCommandEnabledFieldNumber = 3;
  inline bool commandenabled() const;
  inline void set_commandenabled(bool value);

  // required bool attitudeEnabled = 4;
  inline bool has_attitudeenabled() const;
  inline void clear_attitudeenabled();
  static const int kAttitudeEnabledFieldNumber = 4;
  inline bool attitudeenabled() const;
  inline void set_attitudeenabled(bool value);

  // required bool controlEnabled = 5;
  inline bool has_controlenabled() const;
  inline void clear_controlenabled();
  static const int kControlEnabledFieldNumber = 5;
  inline bool controlenabled() const;
  inline void set_controlenabled(bool value);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.CommandPacket.TelemetryConfig)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_commandenabled();
  inline void clear_has_commandenabled();
  inline void set_has_attitudeenabled();
  inline void clear_has_attitudeenabled();
  inline void set_has_controlenabled();
  inline void clear_has_controlenabled();

  ::std::string* host_;
  ::google::protobuf::int32 port_;
  bool commandenabled_;
  bool attitudeenabled_;
  bool controlenabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static CommandPacket_TelemetryConfig* default_instance_;
};
// -------------------------------------------------------------------

class CommandPacket_SensorsConfig : public ::google::protobuf::MessageLite {
 public:
  CommandPacket_SensorsConfig();
  virtual ~CommandPacket_SensorsConfig();

  CommandPacket_SensorsConfig(const CommandPacket_SensorsConfig& from);

  inline CommandPacket_SensorsConfig& operator=(const CommandPacket_SensorsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const CommandPacket_SensorsConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPacket_SensorsConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPacket_SensorsConfig* other);

  // implements Message ----------------------------------------------

  CommandPacket_SensorsConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPacket_SensorsConfig& from);
  void MergeFrom(const CommandPacket_SensorsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float accel_lowpass_constant = 1;
  inline bool has_accel_lowpass_constant() const;
  inline void clear_accel_lowpass_constant();
  static const int kAccelLowpassConstantFieldNumber = 1;
  inline float accel_lowpass_constant() const;
  inline void set_accel_lowpass_constant(float value);

  // required float gyro_roll_bias = 2;
  inline bool has_gyro_roll_bias() const;
  inline void clear_gyro_roll_bias();
  static const int kGyroRollBiasFieldNumber = 2;
  inline float gyro_roll_bias() const;
  inline void set_gyro_roll_bias(float value);

  // required float gyro_pitch_bias = 3;
  inline bool has_gyro_pitch_bias() const;
  inline void clear_gyro_pitch_bias();
  static const int kGyroPitchBiasFieldNumber = 3;
  inline float gyro_pitch_bias() const;
  inline void set_gyro_pitch_bias(float value);

  // required float gyro_yaw_bias = 4;
  inline bool has_gyro_yaw_bias() const;
  inline void clear_gyro_yaw_bias();
  static const int kGyroYawBiasFieldNumber = 4;
  inline float gyro_yaw_bias() const;
  inline void set_gyro_yaw_bias(float value);

  // required float accel_roll_bias = 5;
  inline bool has_accel_roll_bias() const;
  inline void clear_accel_roll_bias();
  static const int kAccelRollBiasFieldNumber = 5;
  inline float accel_roll_bias() const;
  inline void set_accel_roll_bias(float value);

  // required float accel_pitch_bias = 6;
  inline bool has_accel_pitch_bias() const;
  inline void clear_accel_pitch_bias();
  static const int kAccelPitchBiasFieldNumber = 6;
  inline float accel_pitch_bias() const;
  inline void set_accel_pitch_bias(float value);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.CommandPacket.SensorsConfig)
 private:
  inline void set_has_accel_lowpass_constant();
  inline void clear_has_accel_lowpass_constant();
  inline void set_has_gyro_roll_bias();
  inline void clear_has_gyro_roll_bias();
  inline void set_has_gyro_pitch_bias();
  inline void clear_has_gyro_pitch_bias();
  inline void set_has_gyro_yaw_bias();
  inline void clear_has_gyro_yaw_bias();
  inline void set_has_accel_roll_bias();
  inline void clear_has_accel_roll_bias();
  inline void set_has_accel_pitch_bias();
  inline void clear_has_accel_pitch_bias();

  float accel_lowpass_constant_;
  float gyro_roll_bias_;
  float gyro_pitch_bias_;
  float gyro_yaw_bias_;
  float accel_roll_bias_;
  float accel_pitch_bias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static CommandPacket_SensorsConfig* default_instance_;
};
// -------------------------------------------------------------------

class CommandPacket_MotorsConfig : public ::google::protobuf::MessageLite {
 public:
  CommandPacket_MotorsConfig();
  virtual ~CommandPacket_MotorsConfig();

  CommandPacket_MotorsConfig(const CommandPacket_MotorsConfig& from);

  inline CommandPacket_MotorsConfig& operator=(const CommandPacket_MotorsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const CommandPacket_MotorsConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPacket_MotorsConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPacket_MotorsConfig* other);

  // implements Message ----------------------------------------------

  CommandPacket_MotorsConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPacket_MotorsConfig& from);
  void MergeFrom(const CommandPacket_MotorsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 min_pwm = 1;
  inline bool has_min_pwm() const;
  inline void clear_min_pwm();
  static const int kMinPwmFieldNumber = 1;
  inline ::google::protobuf::int32 min_pwm() const;
  inline void set_min_pwm(::google::protobuf::int32 value);

  // required int32 max_pwm = 2;
  inline bool has_max_pwm() const;
  inline void clear_max_pwm();
  static const int kMaxPwmFieldNumber = 2;
  inline ::google::protobuf::int32 max_pwm() const;
  inline void set_max_pwm(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.CommandPacket.MotorsConfig)
 private:
  inline void set_has_min_pwm();
  inline void clear_has_min_pwm();
  inline void set_has_max_pwm();
  inline void clear_has_max_pwm();

  ::google::protobuf::int32 min_pwm_;
  ::google::protobuf::int32 max_pwm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static CommandPacket_MotorsConfig* default_instance_;
};
// -------------------------------------------------------------------

class CommandPacket : public ::google::protobuf::MessageLite {
 public:
  CommandPacket();
  virtual ~CommandPacket();

  CommandPacket(const CommandPacket& from);

  inline CommandPacket& operator=(const CommandPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const CommandPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPacket* other);

  // implements Message ----------------------------------------------

  CommandPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPacket& from);
  void MergeFrom(const CommandPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommandPacket_ControllerConfig ControllerConfig;
  typedef CommandPacket_TelemetryConfig TelemetryConfig;
  typedef CommandPacket_SensorsConfig SensorsConfig;
  typedef CommandPacket_MotorsConfig MotorsConfig;

  // accessors -------------------------------------------------------

  // optional .org.hummingdroid.Attitude command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::org::hummingdroid::Attitude& command() const;
  inline ::org::hummingdroid::Attitude* mutable_command();
  inline ::org::hummingdroid::Attitude* release_command();
  inline void set_allocated_command(::org::hummingdroid::Attitude* command);

  // optional .org.hummingdroid.CommandPacket.ControllerConfig controller_config = 2;
  inline bool has_controller_config() const;
  inline void clear_controller_config();
  static const int kControllerConfigFieldNumber = 2;
  inline const ::org::hummingdroid::CommandPacket_ControllerConfig& controller_config() const;
  inline ::org::hummingdroid::CommandPacket_ControllerConfig* mutable_controller_config();
  inline ::org::hummingdroid::CommandPacket_ControllerConfig* release_controller_config();
  inline void set_allocated_controller_config(::org::hummingdroid::CommandPacket_ControllerConfig* controller_config);

  // optional .org.hummingdroid.CommandPacket.TelemetryConfig telemetry_config = 3;
  inline bool has_telemetry_config() const;
  inline void clear_telemetry_config();
  static const int kTelemetryConfigFieldNumber = 3;
  inline const ::org::hummingdroid::CommandPacket_TelemetryConfig& telemetry_config() const;
  inline ::org::hummingdroid::CommandPacket_TelemetryConfig* mutable_telemetry_config();
  inline ::org::hummingdroid::CommandPacket_TelemetryConfig* release_telemetry_config();
  inline void set_allocated_telemetry_config(::org::hummingdroid::CommandPacket_TelemetryConfig* telemetry_config);

  // optional .org.hummingdroid.CommandPacket.SensorsConfig sensors_config = 4;
  inline bool has_sensors_config() const;
  inline void clear_sensors_config();
  static const int kSensorsConfigFieldNumber = 4;
  inline const ::org::hummingdroid::CommandPacket_SensorsConfig& sensors_config() const;
  inline ::org::hummingdroid::CommandPacket_SensorsConfig* mutable_sensors_config();
  inline ::org::hummingdroid::CommandPacket_SensorsConfig* release_sensors_config();
  inline void set_allocated_sensors_config(::org::hummingdroid::CommandPacket_SensorsConfig* sensors_config);

  // optional .org.hummingdroid.CommandPacket.MotorsConfig motors_config = 5;
  inline bool has_motors_config() const;
  inline void clear_motors_config();
  static const int kMotorsConfigFieldNumber = 5;
  inline const ::org::hummingdroid::CommandPacket_MotorsConfig& motors_config() const;
  inline ::org::hummingdroid::CommandPacket_MotorsConfig* mutable_motors_config();
  inline ::org::hummingdroid::CommandPacket_MotorsConfig* release_motors_config();
  inline void set_allocated_motors_config(::org::hummingdroid::CommandPacket_MotorsConfig* motors_config);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.CommandPacket)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_controller_config();
  inline void clear_has_controller_config();
  inline void set_has_telemetry_config();
  inline void clear_has_telemetry_config();
  inline void set_has_sensors_config();
  inline void clear_has_sensors_config();
  inline void set_has_motors_config();
  inline void clear_has_motors_config();

  ::org::hummingdroid::Attitude* command_;
  ::org::hummingdroid::CommandPacket_ControllerConfig* controller_config_;
  ::org::hummingdroid::CommandPacket_TelemetryConfig* telemetry_config_;
  ::org::hummingdroid::CommandPacket_SensorsConfig* sensors_config_;
  ::org::hummingdroid::CommandPacket_MotorsConfig* motors_config_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static CommandPacket* default_instance_;
};
// -------------------------------------------------------------------

class TelemetryPacket : public ::google::protobuf::MessageLite {
 public:
  TelemetryPacket();
  virtual ~TelemetryPacket();

  TelemetryPacket(const TelemetryPacket& from);

  inline TelemetryPacket& operator=(const TelemetryPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const TelemetryPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TelemetryPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TelemetryPacket* other);

  // implements Message ----------------------------------------------

  TelemetryPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TelemetryPacket& from);
  void MergeFrom(const TelemetryPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .org.hummingdroid.Attitude command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::org::hummingdroid::Attitude& command() const;
  inline ::org::hummingdroid::Attitude* mutable_command();
  inline ::org::hummingdroid::Attitude* release_command();
  inline void set_allocated_command(::org::hummingdroid::Attitude* command);

  // optional .org.hummingdroid.Attitude attitude = 2;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 2;
  inline const ::org::hummingdroid::Attitude& attitude() const;
  inline ::org::hummingdroid::Attitude* mutable_attitude();
  inline ::org::hummingdroid::Attitude* release_attitude();
  inline void set_allocated_attitude(::org::hummingdroid::Attitude* attitude);

  // optional .org.hummingdroid.MotorsControl control = 3;
  inline bool has_control() const;
  inline void clear_control();
  static const int kControlFieldNumber = 3;
  inline const ::org::hummingdroid::MotorsControl& control() const;
  inline ::org::hummingdroid::MotorsControl* mutable_control();
  inline ::org::hummingdroid::MotorsControl* release_control();
  inline void set_allocated_control(::org::hummingdroid::MotorsControl* control);

  // @@protoc_insertion_point(class_scope:org.hummingdroid.TelemetryPacket)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_attitude();
  inline void clear_has_attitude();
  inline void set_has_control();
  inline void clear_has_control();

  ::org::hummingdroid::Attitude* command_;
  ::org::hummingdroid::Attitude* attitude_;
  ::org::hummingdroid::MotorsControl* control_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Communication_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Communication_2eproto();
  #endif
  friend void protobuf_AssignDesc_Communication_2eproto();
  friend void protobuf_ShutdownFile_Communication_2eproto();

  void InitAsDefaultInstance();
  static TelemetryPacket* default_instance_;
};
// ===================================================================


// ===================================================================

// Attitude

// required float altitude = 1;
inline bool Attitude::has_altitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attitude::set_has_altitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attitude::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attitude::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline float Attitude::altitude() const {
  return altitude_;
}
inline void Attitude::set_altitude(float value) {
  set_has_altitude();
  altitude_ = value;
}

// required float roll = 2;
inline bool Attitude::has_roll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attitude::set_has_roll() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attitude::clear_has_roll() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attitude::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float Attitude::roll() const {
  return roll_;
}
inline void Attitude::set_roll(float value) {
  set_has_roll();
  roll_ = value;
}

// required float pitch = 3;
inline bool Attitude::has_pitch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attitude::set_has_pitch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attitude::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attitude::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float Attitude::pitch() const {
  return pitch_;
}
inline void Attitude::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
}

// required float yaw_rate = 4;
inline bool Attitude::has_yaw_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attitude::set_has_yaw_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attitude::clear_has_yaw_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attitude::clear_yaw_rate() {
  yaw_rate_ = 0;
  clear_has_yaw_rate();
}
inline float Attitude::yaw_rate() const {
  return yaw_rate_;
}
inline void Attitude::set_yaw_rate(float value) {
  set_has_yaw_rate();
  yaw_rate_ = value;
}

// optional double timestamp = 5;
inline bool Attitude::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Attitude::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Attitude::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Attitude::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Attitude::timestamp() const {
  return timestamp_;
}
inline void Attitude::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// MotorsControl

// required float altitude_throttle = 1;
inline bool MotorsControl::has_altitude_throttle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotorsControl::set_has_altitude_throttle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotorsControl::clear_has_altitude_throttle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotorsControl::clear_altitude_throttle() {
  altitude_throttle_ = 0;
  clear_has_altitude_throttle();
}
inline float MotorsControl::altitude_throttle() const {
  return altitude_throttle_;
}
inline void MotorsControl::set_altitude_throttle(float value) {
  set_has_altitude_throttle();
  altitude_throttle_ = value;
}

// required float roll_throttle = 2;
inline bool MotorsControl::has_roll_throttle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotorsControl::set_has_roll_throttle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotorsControl::clear_has_roll_throttle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotorsControl::clear_roll_throttle() {
  roll_throttle_ = 0;
  clear_has_roll_throttle();
}
inline float MotorsControl::roll_throttle() const {
  return roll_throttle_;
}
inline void MotorsControl::set_roll_throttle(float value) {
  set_has_roll_throttle();
  roll_throttle_ = value;
}

// required float pitch_throttle = 3;
inline bool MotorsControl::has_pitch_throttle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotorsControl::set_has_pitch_throttle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotorsControl::clear_has_pitch_throttle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotorsControl::clear_pitch_throttle() {
  pitch_throttle_ = 0;
  clear_has_pitch_throttle();
}
inline float MotorsControl::pitch_throttle() const {
  return pitch_throttle_;
}
inline void MotorsControl::set_pitch_throttle(float value) {
  set_has_pitch_throttle();
  pitch_throttle_ = value;
}

// required float yaw_throttle = 4;
inline bool MotorsControl::has_yaw_throttle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotorsControl::set_has_yaw_throttle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotorsControl::clear_has_yaw_throttle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotorsControl::clear_yaw_throttle() {
  yaw_throttle_ = 0;
  clear_has_yaw_throttle();
}
inline float MotorsControl::yaw_throttle() const {
  return yaw_throttle_;
}
inline void MotorsControl::set_yaw_throttle(float value) {
  set_has_yaw_throttle();
  yaw_throttle_ = value;
}

// optional double timestamp = 5;
inline bool MotorsControl::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MotorsControl::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MotorsControl::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MotorsControl::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double MotorsControl::timestamp() const {
  return timestamp_;
}
inline void MotorsControl::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// PID

// required float Kp = 1;
inline bool PID::has_kp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PID::set_has_kp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PID::clear_has_kp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PID::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
inline float PID::kp() const {
  return kp_;
}
inline void PID::set_kp(float value) {
  set_has_kp();
  kp_ = value;
}

// required float Ki = 2;
inline bool PID::has_ki() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PID::set_has_ki() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PID::clear_has_ki() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PID::clear_ki() {
  ki_ = 0;
  clear_has_ki();
}
inline float PID::ki() const {
  return ki_;
}
inline void PID::set_ki(float value) {
  set_has_ki();
  ki_ = value;
}

// required float Kd = 3;
inline bool PID::has_kd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PID::set_has_kd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PID::clear_has_kd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PID::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline float PID::kd() const {
  return kd_;
}
inline void PID::set_kd(float value) {
  set_has_kd();
  kd_ = value;
}

// required float Ko = 4;
inline bool PID::has_ko() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PID::set_has_ko() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PID::clear_has_ko() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PID::clear_ko() {
  ko_ = 0;
  clear_has_ko();
}
inline float PID::ko() const {
  return ko_;
}
inline void PID::set_ko(float value) {
  set_has_ko();
  ko_ = value;
}

// required float Td = 5;
inline bool PID::has_td() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PID::set_has_td() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PID::clear_has_td() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PID::clear_td() {
  td_ = 0;
  clear_has_td();
}
inline float PID::td() const {
  return td_;
}
inline void PID::set_td(float value) {
  set_has_td();
  td_ = value;
}

// -------------------------------------------------------------------

// CommandPacket_ControllerConfig

// required .org.hummingdroid.PID altitude_pid = 1;
inline bool CommandPacket_ControllerConfig::has_altitude_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPacket_ControllerConfig::set_has_altitude_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPacket_ControllerConfig::clear_has_altitude_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPacket_ControllerConfig::clear_altitude_pid() {
  if (altitude_pid_ != NULL) altitude_pid_->::org::hummingdroid::PID::Clear();
  clear_has_altitude_pid();
}
inline const ::org::hummingdroid::PID& CommandPacket_ControllerConfig::altitude_pid() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return altitude_pid_ != NULL ? *altitude_pid_ : *default_instance().altitude_pid_;
#else
  return altitude_pid_ != NULL ? *altitude_pid_ : *default_instance_->altitude_pid_;
#endif
}
inline ::org::hummingdroid::PID* CommandPacket_ControllerConfig::mutable_altitude_pid() {
  set_has_altitude_pid();
  if (altitude_pid_ == NULL) altitude_pid_ = new ::org::hummingdroid::PID;
  return altitude_pid_;
}
inline ::org::hummingdroid::PID* CommandPacket_ControllerConfig::release_altitude_pid() {
  clear_has_altitude_pid();
  ::org::hummingdroid::PID* temp = altitude_pid_;
  altitude_pid_ = NULL;
  return temp;
}
inline void CommandPacket_ControllerConfig::set_allocated_altitude_pid(::org::hummingdroid::PID* altitude_pid) {
  delete altitude_pid_;
  altitude_pid_ = altitude_pid;
  if (altitude_pid) {
    set_has_altitude_pid();
  } else {
    clear_has_altitude_pid();
  }
}

// required .org.hummingdroid.PID roll_pid = 2;
inline bool CommandPacket_ControllerConfig::has_roll_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPacket_ControllerConfig::set_has_roll_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPacket_ControllerConfig::clear_has_roll_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPacket_ControllerConfig::clear_roll_pid() {
  if (roll_pid_ != NULL) roll_pid_->::org::hummingdroid::PID::Clear();
  clear_has_roll_pid();
}
inline const ::org::hummingdroid::PID& CommandPacket_ControllerConfig::roll_pid() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return roll_pid_ != NULL ? *roll_pid_ : *default_instance().roll_pid_;
#else
  return roll_pid_ != NULL ? *roll_pid_ : *default_instance_->roll_pid_;
#endif
}
inline ::org::hummingdroid::PID* CommandPacket_ControllerConfig::mutable_roll_pid() {
  set_has_roll_pid();
  if (roll_pid_ == NULL) roll_pid_ = new ::org::hummingdroid::PID;
  return roll_pid_;
}
inline ::org::hummingdroid::PID* CommandPacket_ControllerConfig::release_roll_pid() {
  clear_has_roll_pid();
  ::org::hummingdroid::PID* temp = roll_pid_;
  roll_pid_ = NULL;
  return temp;
}
inline void CommandPacket_ControllerConfig::set_allocated_roll_pid(::org::hummingdroid::PID* roll_pid) {
  delete roll_pid_;
  roll_pid_ = roll_pid;
  if (roll_pid) {
    set_has_roll_pid();
  } else {
    clear_has_roll_pid();
  }
}

// required .org.hummingdroid.PID pitch_pid = 3;
inline bool CommandPacket_ControllerConfig::has_pitch_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPacket_ControllerConfig::set_has_pitch_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPacket_ControllerConfig::clear_has_pitch_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPacket_ControllerConfig::clear_pitch_pid() {
  if (pitch_pid_ != NULL) pitch_pid_->::org::hummingdroid::PID::Clear();
  clear_has_pitch_pid();
}
inline const ::org::hummingdroid::PID& CommandPacket_ControllerConfig::pitch_pid() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pitch_pid_ != NULL ? *pitch_pid_ : *default_instance().pitch_pid_;
#else
  return pitch_pid_ != NULL ? *pitch_pid_ : *default_instance_->pitch_pid_;
#endif
}
inline ::org::hummingdroid::PID* CommandPacket_ControllerConfig::mutable_pitch_pid() {
  set_has_pitch_pid();
  if (pitch_pid_ == NULL) pitch_pid_ = new ::org::hummingdroid::PID;
  return pitch_pid_;
}
inline ::org::hummingdroid::PID* CommandPacket_ControllerConfig::release_pitch_pid() {
  clear_has_pitch_pid();
  ::org::hummingdroid::PID* temp = pitch_pid_;
  pitch_pid_ = NULL;
  return temp;
}
inline void CommandPacket_ControllerConfig::set_allocated_pitch_pid(::org::hummingdroid::PID* pitch_pid) {
  delete pitch_pid_;
  pitch_pid_ = pitch_pid;
  if (pitch_pid) {
    set_has_pitch_pid();
  } else {
    clear_has_pitch_pid();
  }
}

// required .org.hummingdroid.PID yaw_rate_pid = 4;
inline bool CommandPacket_ControllerConfig::has_yaw_rate_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPacket_ControllerConfig::set_has_yaw_rate_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPacket_ControllerConfig::clear_has_yaw_rate_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPacket_ControllerConfig::clear_yaw_rate_pid() {
  if (yaw_rate_pid_ != NULL) yaw_rate_pid_->::org::hummingdroid::PID::Clear();
  clear_has_yaw_rate_pid();
}
inline const ::org::hummingdroid::PID& CommandPacket_ControllerConfig::yaw_rate_pid() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return yaw_rate_pid_ != NULL ? *yaw_rate_pid_ : *default_instance().yaw_rate_pid_;
#else
  return yaw_rate_pid_ != NULL ? *yaw_rate_pid_ : *default_instance_->yaw_rate_pid_;
#endif
}
inline ::org::hummingdroid::PID* CommandPacket_ControllerConfig::mutable_yaw_rate_pid() {
  set_has_yaw_rate_pid();
  if (yaw_rate_pid_ == NULL) yaw_rate_pid_ = new ::org::hummingdroid::PID;
  return yaw_rate_pid_;
}
inline ::org::hummingdroid::PID* CommandPacket_ControllerConfig::release_yaw_rate_pid() {
  clear_has_yaw_rate_pid();
  ::org::hummingdroid::PID* temp = yaw_rate_pid_;
  yaw_rate_pid_ = NULL;
  return temp;
}
inline void CommandPacket_ControllerConfig::set_allocated_yaw_rate_pid(::org::hummingdroid::PID* yaw_rate_pid) {
  delete yaw_rate_pid_;
  yaw_rate_pid_ = yaw_rate_pid;
  if (yaw_rate_pid) {
    set_has_yaw_rate_pid();
  } else {
    clear_has_yaw_rate_pid();
  }
}

// optional float max_inclinaison = 5;
inline bool CommandPacket_ControllerConfig::has_max_inclinaison() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPacket_ControllerConfig::set_has_max_inclinaison() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPacket_ControllerConfig::clear_has_max_inclinaison() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPacket_ControllerConfig::clear_max_inclinaison() {
  max_inclinaison_ = 0;
  clear_has_max_inclinaison();
}
inline float CommandPacket_ControllerConfig::max_inclinaison() const {
  return max_inclinaison_;
}
inline void CommandPacket_ControllerConfig::set_max_inclinaison(float value) {
  set_has_max_inclinaison();
  max_inclinaison_ = value;
}

// optional float max_altitude = 6;
inline bool CommandPacket_ControllerConfig::has_max_altitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandPacket_ControllerConfig::set_has_max_altitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandPacket_ControllerConfig::clear_has_max_altitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandPacket_ControllerConfig::clear_max_altitude() {
  max_altitude_ = 0;
  clear_has_max_altitude();
}
inline float CommandPacket_ControllerConfig::max_altitude() const {
  return max_altitude_;
}
inline void CommandPacket_ControllerConfig::set_max_altitude(float value) {
  set_has_max_altitude();
  max_altitude_ = value;
}

// optional float max_yaw_rate = 7;
inline bool CommandPacket_ControllerConfig::has_max_yaw_rate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandPacket_ControllerConfig::set_has_max_yaw_rate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandPacket_ControllerConfig::clear_has_max_yaw_rate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandPacket_ControllerConfig::clear_max_yaw_rate() {
  max_yaw_rate_ = 0;
  clear_has_max_yaw_rate();
}
inline float CommandPacket_ControllerConfig::max_yaw_rate() const {
  return max_yaw_rate_;
}
inline void CommandPacket_ControllerConfig::set_max_yaw_rate(float value) {
  set_has_max_yaw_rate();
  max_yaw_rate_ = value;
}

// -------------------------------------------------------------------

// CommandPacket_TelemetryConfig

// required string host = 1;
inline bool CommandPacket_TelemetryConfig::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPacket_TelemetryConfig::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPacket_TelemetryConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPacket_TelemetryConfig::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& CommandPacket_TelemetryConfig::host() const {
  return *host_;
}
inline void CommandPacket_TelemetryConfig::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void CommandPacket_TelemetryConfig::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void CommandPacket_TelemetryConfig::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandPacket_TelemetryConfig::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* CommandPacket_TelemetryConfig::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandPacket_TelemetryConfig::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 2;
inline bool CommandPacket_TelemetryConfig::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPacket_TelemetryConfig::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPacket_TelemetryConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPacket_TelemetryConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 CommandPacket_TelemetryConfig::port() const {
  return port_;
}
inline void CommandPacket_TelemetryConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required bool commandEnabled = 3;
inline bool CommandPacket_TelemetryConfig::has_commandenabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPacket_TelemetryConfig::set_has_commandenabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPacket_TelemetryConfig::clear_has_commandenabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPacket_TelemetryConfig::clear_commandenabled() {
  commandenabled_ = false;
  clear_has_commandenabled();
}
inline bool CommandPacket_TelemetryConfig::commandenabled() const {
  return commandenabled_;
}
inline void CommandPacket_TelemetryConfig::set_commandenabled(bool value) {
  set_has_commandenabled();
  commandenabled_ = value;
}

// required bool attitudeEnabled = 4;
inline bool CommandPacket_TelemetryConfig::has_attitudeenabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPacket_TelemetryConfig::set_has_attitudeenabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPacket_TelemetryConfig::clear_has_attitudeenabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPacket_TelemetryConfig::clear_attitudeenabled() {
  attitudeenabled_ = false;
  clear_has_attitudeenabled();
}
inline bool CommandPacket_TelemetryConfig::attitudeenabled() const {
  return attitudeenabled_;
}
inline void CommandPacket_TelemetryConfig::set_attitudeenabled(bool value) {
  set_has_attitudeenabled();
  attitudeenabled_ = value;
}

// required bool controlEnabled = 5;
inline bool CommandPacket_TelemetryConfig::has_controlenabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPacket_TelemetryConfig::set_has_controlenabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPacket_TelemetryConfig::clear_has_controlenabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPacket_TelemetryConfig::clear_controlenabled() {
  controlenabled_ = false;
  clear_has_controlenabled();
}
inline bool CommandPacket_TelemetryConfig::controlenabled() const {
  return controlenabled_;
}
inline void CommandPacket_TelemetryConfig::set_controlenabled(bool value) {
  set_has_controlenabled();
  controlenabled_ = value;
}

// -------------------------------------------------------------------

// CommandPacket_SensorsConfig

// required float accel_lowpass_constant = 1;
inline bool CommandPacket_SensorsConfig::has_accel_lowpass_constant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPacket_SensorsConfig::set_has_accel_lowpass_constant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPacket_SensorsConfig::clear_has_accel_lowpass_constant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPacket_SensorsConfig::clear_accel_lowpass_constant() {
  accel_lowpass_constant_ = 0;
  clear_has_accel_lowpass_constant();
}
inline float CommandPacket_SensorsConfig::accel_lowpass_constant() const {
  return accel_lowpass_constant_;
}
inline void CommandPacket_SensorsConfig::set_accel_lowpass_constant(float value) {
  set_has_accel_lowpass_constant();
  accel_lowpass_constant_ = value;
}

// required float gyro_roll_bias = 2;
inline bool CommandPacket_SensorsConfig::has_gyro_roll_bias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPacket_SensorsConfig::set_has_gyro_roll_bias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPacket_SensorsConfig::clear_has_gyro_roll_bias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPacket_SensorsConfig::clear_gyro_roll_bias() {
  gyro_roll_bias_ = 0;
  clear_has_gyro_roll_bias();
}
inline float CommandPacket_SensorsConfig::gyro_roll_bias() const {
  return gyro_roll_bias_;
}
inline void CommandPacket_SensorsConfig::set_gyro_roll_bias(float value) {
  set_has_gyro_roll_bias();
  gyro_roll_bias_ = value;
}

// required float gyro_pitch_bias = 3;
inline bool CommandPacket_SensorsConfig::has_gyro_pitch_bias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPacket_SensorsConfig::set_has_gyro_pitch_bias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPacket_SensorsConfig::clear_has_gyro_pitch_bias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPacket_SensorsConfig::clear_gyro_pitch_bias() {
  gyro_pitch_bias_ = 0;
  clear_has_gyro_pitch_bias();
}
inline float CommandPacket_SensorsConfig::gyro_pitch_bias() const {
  return gyro_pitch_bias_;
}
inline void CommandPacket_SensorsConfig::set_gyro_pitch_bias(float value) {
  set_has_gyro_pitch_bias();
  gyro_pitch_bias_ = value;
}

// required float gyro_yaw_bias = 4;
inline bool CommandPacket_SensorsConfig::has_gyro_yaw_bias() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPacket_SensorsConfig::set_has_gyro_yaw_bias() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPacket_SensorsConfig::clear_has_gyro_yaw_bias() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPacket_SensorsConfig::clear_gyro_yaw_bias() {
  gyro_yaw_bias_ = 0;
  clear_has_gyro_yaw_bias();
}
inline float CommandPacket_SensorsConfig::gyro_yaw_bias() const {
  return gyro_yaw_bias_;
}
inline void CommandPacket_SensorsConfig::set_gyro_yaw_bias(float value) {
  set_has_gyro_yaw_bias();
  gyro_yaw_bias_ = value;
}

// required float accel_roll_bias = 5;
inline bool CommandPacket_SensorsConfig::has_accel_roll_bias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPacket_SensorsConfig::set_has_accel_roll_bias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPacket_SensorsConfig::clear_has_accel_roll_bias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPacket_SensorsConfig::clear_accel_roll_bias() {
  accel_roll_bias_ = 0;
  clear_has_accel_roll_bias();
}
inline float CommandPacket_SensorsConfig::accel_roll_bias() const {
  return accel_roll_bias_;
}
inline void CommandPacket_SensorsConfig::set_accel_roll_bias(float value) {
  set_has_accel_roll_bias();
  accel_roll_bias_ = value;
}

// required float accel_pitch_bias = 6;
inline bool CommandPacket_SensorsConfig::has_accel_pitch_bias() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandPacket_SensorsConfig::set_has_accel_pitch_bias() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandPacket_SensorsConfig::clear_has_accel_pitch_bias() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandPacket_SensorsConfig::clear_accel_pitch_bias() {
  accel_pitch_bias_ = 0;
  clear_has_accel_pitch_bias();
}
inline float CommandPacket_SensorsConfig::accel_pitch_bias() const {
  return accel_pitch_bias_;
}
inline void CommandPacket_SensorsConfig::set_accel_pitch_bias(float value) {
  set_has_accel_pitch_bias();
  accel_pitch_bias_ = value;
}

// -------------------------------------------------------------------

// CommandPacket_MotorsConfig

// required int32 min_pwm = 1;
inline bool CommandPacket_MotorsConfig::has_min_pwm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPacket_MotorsConfig::set_has_min_pwm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPacket_MotorsConfig::clear_has_min_pwm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPacket_MotorsConfig::clear_min_pwm() {
  min_pwm_ = 0;
  clear_has_min_pwm();
}
inline ::google::protobuf::int32 CommandPacket_MotorsConfig::min_pwm() const {
  return min_pwm_;
}
inline void CommandPacket_MotorsConfig::set_min_pwm(::google::protobuf::int32 value) {
  set_has_min_pwm();
  min_pwm_ = value;
}

// required int32 max_pwm = 2;
inline bool CommandPacket_MotorsConfig::has_max_pwm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPacket_MotorsConfig::set_has_max_pwm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPacket_MotorsConfig::clear_has_max_pwm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPacket_MotorsConfig::clear_max_pwm() {
  max_pwm_ = 0;
  clear_has_max_pwm();
}
inline ::google::protobuf::int32 CommandPacket_MotorsConfig::max_pwm() const {
  return max_pwm_;
}
inline void CommandPacket_MotorsConfig::set_max_pwm(::google::protobuf::int32 value) {
  set_has_max_pwm();
  max_pwm_ = value;
}

// -------------------------------------------------------------------

// CommandPacket

// optional .org.hummingdroid.Attitude command = 1;
inline bool CommandPacket::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPacket::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPacket::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPacket::clear_command() {
  if (command_ != NULL) command_->::org::hummingdroid::Attitude::Clear();
  clear_has_command();
}
inline const ::org::hummingdroid::Attitude& CommandPacket::command() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return command_ != NULL ? *command_ : *default_instance().command_;
#else
  return command_ != NULL ? *command_ : *default_instance_->command_;
#endif
}
inline ::org::hummingdroid::Attitude* CommandPacket::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::org::hummingdroid::Attitude;
  return command_;
}
inline ::org::hummingdroid::Attitude* CommandPacket::release_command() {
  clear_has_command();
  ::org::hummingdroid::Attitude* temp = command_;
  command_ = NULL;
  return temp;
}
inline void CommandPacket::set_allocated_command(::org::hummingdroid::Attitude* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional .org.hummingdroid.CommandPacket.ControllerConfig controller_config = 2;
inline bool CommandPacket::has_controller_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPacket::set_has_controller_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPacket::clear_has_controller_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPacket::clear_controller_config() {
  if (controller_config_ != NULL) controller_config_->::org::hummingdroid::CommandPacket_ControllerConfig::Clear();
  clear_has_controller_config();
}
inline const ::org::hummingdroid::CommandPacket_ControllerConfig& CommandPacket::controller_config() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return controller_config_ != NULL ? *controller_config_ : *default_instance().controller_config_;
#else
  return controller_config_ != NULL ? *controller_config_ : *default_instance_->controller_config_;
#endif
}
inline ::org::hummingdroid::CommandPacket_ControllerConfig* CommandPacket::mutable_controller_config() {
  set_has_controller_config();
  if (controller_config_ == NULL) controller_config_ = new ::org::hummingdroid::CommandPacket_ControllerConfig;
  return controller_config_;
}
inline ::org::hummingdroid::CommandPacket_ControllerConfig* CommandPacket::release_controller_config() {
  clear_has_controller_config();
  ::org::hummingdroid::CommandPacket_ControllerConfig* temp = controller_config_;
  controller_config_ = NULL;
  return temp;
}
inline void CommandPacket::set_allocated_controller_config(::org::hummingdroid::CommandPacket_ControllerConfig* controller_config) {
  delete controller_config_;
  controller_config_ = controller_config;
  if (controller_config) {
    set_has_controller_config();
  } else {
    clear_has_controller_config();
  }
}

// optional .org.hummingdroid.CommandPacket.TelemetryConfig telemetry_config = 3;
inline bool CommandPacket::has_telemetry_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPacket::set_has_telemetry_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPacket::clear_has_telemetry_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPacket::clear_telemetry_config() {
  if (telemetry_config_ != NULL) telemetry_config_->::org::hummingdroid::CommandPacket_TelemetryConfig::Clear();
  clear_has_telemetry_config();
}
inline const ::org::hummingdroid::CommandPacket_TelemetryConfig& CommandPacket::telemetry_config() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return telemetry_config_ != NULL ? *telemetry_config_ : *default_instance().telemetry_config_;
#else
  return telemetry_config_ != NULL ? *telemetry_config_ : *default_instance_->telemetry_config_;
#endif
}
inline ::org::hummingdroid::CommandPacket_TelemetryConfig* CommandPacket::mutable_telemetry_config() {
  set_has_telemetry_config();
  if (telemetry_config_ == NULL) telemetry_config_ = new ::org::hummingdroid::CommandPacket_TelemetryConfig;
  return telemetry_config_;
}
inline ::org::hummingdroid::CommandPacket_TelemetryConfig* CommandPacket::release_telemetry_config() {
  clear_has_telemetry_config();
  ::org::hummingdroid::CommandPacket_TelemetryConfig* temp = telemetry_config_;
  telemetry_config_ = NULL;
  return temp;
}
inline void CommandPacket::set_allocated_telemetry_config(::org::hummingdroid::CommandPacket_TelemetryConfig* telemetry_config) {
  delete telemetry_config_;
  telemetry_config_ = telemetry_config;
  if (telemetry_config) {
    set_has_telemetry_config();
  } else {
    clear_has_telemetry_config();
  }
}

// optional .org.hummingdroid.CommandPacket.SensorsConfig sensors_config = 4;
inline bool CommandPacket::has_sensors_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPacket::set_has_sensors_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPacket::clear_has_sensors_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPacket::clear_sensors_config() {
  if (sensors_config_ != NULL) sensors_config_->::org::hummingdroid::CommandPacket_SensorsConfig::Clear();
  clear_has_sensors_config();
}
inline const ::org::hummingdroid::CommandPacket_SensorsConfig& CommandPacket::sensors_config() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sensors_config_ != NULL ? *sensors_config_ : *default_instance().sensors_config_;
#else
  return sensors_config_ != NULL ? *sensors_config_ : *default_instance_->sensors_config_;
#endif
}
inline ::org::hummingdroid::CommandPacket_SensorsConfig* CommandPacket::mutable_sensors_config() {
  set_has_sensors_config();
  if (sensors_config_ == NULL) sensors_config_ = new ::org::hummingdroid::CommandPacket_SensorsConfig;
  return sensors_config_;
}
inline ::org::hummingdroid::CommandPacket_SensorsConfig* CommandPacket::release_sensors_config() {
  clear_has_sensors_config();
  ::org::hummingdroid::CommandPacket_SensorsConfig* temp = sensors_config_;
  sensors_config_ = NULL;
  return temp;
}
inline void CommandPacket::set_allocated_sensors_config(::org::hummingdroid::CommandPacket_SensorsConfig* sensors_config) {
  delete sensors_config_;
  sensors_config_ = sensors_config;
  if (sensors_config) {
    set_has_sensors_config();
  } else {
    clear_has_sensors_config();
  }
}

// optional .org.hummingdroid.CommandPacket.MotorsConfig motors_config = 5;
inline bool CommandPacket::has_motors_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPacket::set_has_motors_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPacket::clear_has_motors_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPacket::clear_motors_config() {
  if (motors_config_ != NULL) motors_config_->::org::hummingdroid::CommandPacket_MotorsConfig::Clear();
  clear_has_motors_config();
}
inline const ::org::hummingdroid::CommandPacket_MotorsConfig& CommandPacket::motors_config() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return motors_config_ != NULL ? *motors_config_ : *default_instance().motors_config_;
#else
  return motors_config_ != NULL ? *motors_config_ : *default_instance_->motors_config_;
#endif
}
inline ::org::hummingdroid::CommandPacket_MotorsConfig* CommandPacket::mutable_motors_config() {
  set_has_motors_config();
  if (motors_config_ == NULL) motors_config_ = new ::org::hummingdroid::CommandPacket_MotorsConfig;
  return motors_config_;
}
inline ::org::hummingdroid::CommandPacket_MotorsConfig* CommandPacket::release_motors_config() {
  clear_has_motors_config();
  ::org::hummingdroid::CommandPacket_MotorsConfig* temp = motors_config_;
  motors_config_ = NULL;
  return temp;
}
inline void CommandPacket::set_allocated_motors_config(::org::hummingdroid::CommandPacket_MotorsConfig* motors_config) {
  delete motors_config_;
  motors_config_ = motors_config;
  if (motors_config) {
    set_has_motors_config();
  } else {
    clear_has_motors_config();
  }
}

// -------------------------------------------------------------------

// TelemetryPacket

// optional .org.hummingdroid.Attitude command = 1;
inline bool TelemetryPacket::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TelemetryPacket::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TelemetryPacket::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TelemetryPacket::clear_command() {
  if (command_ != NULL) command_->::org::hummingdroid::Attitude::Clear();
  clear_has_command();
}
inline const ::org::hummingdroid::Attitude& TelemetryPacket::command() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return command_ != NULL ? *command_ : *default_instance().command_;
#else
  return command_ != NULL ? *command_ : *default_instance_->command_;
#endif
}
inline ::org::hummingdroid::Attitude* TelemetryPacket::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::org::hummingdroid::Attitude;
  return command_;
}
inline ::org::hummingdroid::Attitude* TelemetryPacket::release_command() {
  clear_has_command();
  ::org::hummingdroid::Attitude* temp = command_;
  command_ = NULL;
  return temp;
}
inline void TelemetryPacket::set_allocated_command(::org::hummingdroid::Attitude* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional .org.hummingdroid.Attitude attitude = 2;
inline bool TelemetryPacket::has_attitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TelemetryPacket::set_has_attitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TelemetryPacket::clear_has_attitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TelemetryPacket::clear_attitude() {
  if (attitude_ != NULL) attitude_->::org::hummingdroid::Attitude::Clear();
  clear_has_attitude();
}
inline const ::org::hummingdroid::Attitude& TelemetryPacket::attitude() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attitude_ != NULL ? *attitude_ : *default_instance().attitude_;
#else
  return attitude_ != NULL ? *attitude_ : *default_instance_->attitude_;
#endif
}
inline ::org::hummingdroid::Attitude* TelemetryPacket::mutable_attitude() {
  set_has_attitude();
  if (attitude_ == NULL) attitude_ = new ::org::hummingdroid::Attitude;
  return attitude_;
}
inline ::org::hummingdroid::Attitude* TelemetryPacket::release_attitude() {
  clear_has_attitude();
  ::org::hummingdroid::Attitude* temp = attitude_;
  attitude_ = NULL;
  return temp;
}
inline void TelemetryPacket::set_allocated_attitude(::org::hummingdroid::Attitude* attitude) {
  delete attitude_;
  attitude_ = attitude;
  if (attitude) {
    set_has_attitude();
  } else {
    clear_has_attitude();
  }
}

// optional .org.hummingdroid.MotorsControl control = 3;
inline bool TelemetryPacket::has_control() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TelemetryPacket::set_has_control() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TelemetryPacket::clear_has_control() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TelemetryPacket::clear_control() {
  if (control_ != NULL) control_->::org::hummingdroid::MotorsControl::Clear();
  clear_has_control();
}
inline const ::org::hummingdroid::MotorsControl& TelemetryPacket::control() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return control_ != NULL ? *control_ : *default_instance().control_;
#else
  return control_ != NULL ? *control_ : *default_instance_->control_;
#endif
}
inline ::org::hummingdroid::MotorsControl* TelemetryPacket::mutable_control() {
  set_has_control();
  if (control_ == NULL) control_ = new ::org::hummingdroid::MotorsControl;
  return control_;
}
inline ::org::hummingdroid::MotorsControl* TelemetryPacket::release_control() {
  clear_has_control();
  ::org::hummingdroid::MotorsControl* temp = control_;
  control_ = NULL;
  return temp;
}
inline void TelemetryPacket::set_allocated_control(::org::hummingdroid::MotorsControl* control) {
  delete control_;
  control_ = control;
  if (control) {
    set_has_control();
  } else {
    clear_has_control();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace hummingdroid
}  // namespace org

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Communication_2eproto__INCLUDED
